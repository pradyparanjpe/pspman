#!/usr/bin/env bash
# -*- coding:utf-8; mode:shell-script -*-
#
# Copyright 2020 Pradyumna Paranjape
# This file is part of pspman.
#
# pspman is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pspman is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pspman.  If not, see <https://www.gnu.org/licenses/>.
#


function init() {
    USE_MSG="
Usage:
$ gitman [-h] [-c DIR] [-p PREF] [-f] [-o] [[-i URL] [-i URL]...] [[-d PROJ] [-d PROJ]...]

NOTICE: This is only intended for \"user\" installs.
CAUTION: DO NOT RUN THIS SCRIPT AS ROOT
CAUTION: If you still insist, I won't care.

Optional arguments:
-c|--clonedir DIR\tPath for all git clones [default:${HOME}/programs]
-p|--prefix PREF\tPath for installation [default:${HOME}]
-f|--force-root\t\tForce working with root permissions [DANGEROUS]
-o|--only_pull\t\tOnly pull, do not try to install
-i|--install URL\tURL to clone new project
-d|--delete PROJ\tDelete PROJ
"

    CLONE_DIR=
    INSTALL=true
    PREFIX=
    USER_WD=
    FORCE_ROOT=
    INSTALL_LIST=()
    PROJECT_LIST=()
    PULL_SUCCESS=()
    DEL_PACK=()
}

function exitDoor() {
    USE_MSG=
    CLONE_DIR=
    INSTALL=
    PREFIX=
    INSTALL_LIST=
    USER_WD=
    FORCE_ROOT=
    PROJECT_LIST=
    PULL_SUCCESS=
    DEL_PACK=
    exit "$1"
}

function argParse () {
    while test $# -gt 0; do
        case $1 in
            -h|--help)
                echo -e "$USE_MSG"
                exitDoor 0;
                ;;
            -f|--force-root)
                FORCE_ROOT=true
                shift
                ;;
            -c|--clonedir)
                shift
                CLONE_DIR=$1
                shift
                ;;
            -d|--delete)
                shift
                DEL_PACK+=( $1 )
                shift
                ;;
            -o|--only_pull)
                INSTALL=
                shift
                ;;
            -p|--prefix)
                shift
                PREFIX=$1
                shift
                ;;
            -i|--install)
                shift
                INSTALL_LIST+=( $1 )
                shift
                ;;
            *)
                echo "Bad command usage"
                echo -e "$USE_MSG"
                exitDoor 1;
                ;;
        esac
    done
}

function fill_defaults() {
    [[ -z "$USER_WD" ]] && USER_WD="$PWD"
    [[ -z "$CLONE_DIR" ]] && CLONE_DIR="${HOME}/programs"
    [[ -z "$PREFIX" ]] && PREFIX="${HOME}"
}

function perm_pass() {
    permdir="$1"
    perms=
    perminfo=( $(stat -Lc "%U %G %a" "$permdir") )
    owner=${perminfo[0]}
    group=${perminfo[1]}
    octperm=${perminfo[2]}
    if (( ($octperm & 0007) != 0 )); then
        # everyone has access
        perms=true
    elif (( ($octperm & 0070) !=0 )); then
        # some group has permissions
        user_groups=( $(groups $USER) )
        for ug in $user_groups; do
            if [[ $ug == $group ]]; then
                perms=true
                break
            fi
        done
    elif (( ($octperm & 00700) !=0 )); then
        # owner has permissions
        if [[ $USER == $owner ]]; then
            perms=true
        fi
    fi
    if [[ -z $perms ]]; then
        perms=
        echo "[ERROR] We don't have read|write|execute permissions on $permdir"
        echo "[SUGGEST] Try some other location"
        echo "Bye"
        exit 1
    fi
    perms=
    permdir=
}

function permission_check() {
    # Am I root?
    if [[ "$(id -u)" == "0" ]]; then
        echo "[WARNING] I hate dictators"
        if [[ -z "$FORCE_ROOT" ]]; then
            echo "Bye"
            exitDoor 2
        fi
        echo "[WARNING] I can only hope you know what you are doing..."
        printf "[ACT] Here is a chance to kill me in then next 10 seconds..."
        for time_out in {1..10}; do
            sleep 1
            printf "\b\b\b\b\b\b\b\b\b\b\b\b\b"
            printf " $((10 - time_out)) seconds..."
        done
        printf "\b\b\b\b\b\b\b\b\b\b\b\b\b"
        printf "10 seconds..."
        echo ""
        echo ""
        echo "[INFO] ¯\_(ツ)_/¯ Your decision ¯\_(ツ)_/¯"
        echo ""
        echo "[INFO] Proceeding..."
        perms=true
    # Is installation directory read/writable
    else
        clonedir=$CLONE_DIR;
        while [[ ! -d "$clonedir" ]]; do
            clonedir=$(dirname "$permdir")
        done
        perm_pass "$clonedir"
        perm_pass "$PREFIX"
    fi
}

function find_gits() {
    count=0
    for project in $CLONE_DIR/*; do
        if [[ -d "$project" ]]; then
            if [[ -d "$project/.git" ]]; then
                PROJECT_LIST+=($project)
                count=$(( count + 1 ))
            fi
        fi
    done
    echo "[INFO] Trying to refresh $count project(s)"
    count=
}

function git_pulls() {
    fails=0
    for git_project in ${PROJECT_LIST[@]}; do
        cd "$git_project"
        git_success="$(git pull)"
        if [[ "$git_success" =~ "Already up to date" ]]; then
            true
        else
            echo ""
            echo "[INFO] Updating $PWD"
            if [[ "$git_success" =~ "+" \
                      || "$git_success" =~ "-" ]]; then
                PULL_SUCCESS+=($git_project)
            else
                fails=$(( fail + 1))
                echo "[WARNING] Failed in $PWD"
            fi
        fi
    done
    cd "$USER_WD"
    for updates in ${PULL_SUCCESS[@]}; do
        echo "[INFO] Updated $updates"
    done
    echo ""
    if [[ $fails -ne 0 ]]; then
        echo "[INFO] $fails project updates failed"
    fi
    fails=
    git_success=
}

function bootstrap_install() {
    if [[ -n "$INSTALL" ]]; then
        case $2 in
            make)
                echo "[INFO] Trying automated ./configure -> make -> install"
                echo "[contd..] In $1"
                cd "$1"
                echo "[INFO] Working in $PWD"
                ./configure --prefix="$PREFIX"
                make
                make install
                cd "${USER_WD}"
                ;;
            pysetup)
                echo "[INFO] Trying automated pip install --user ."
                echo "[contd..] In $1"
                cd "$1"
                echo "[INFO] Working in $PWD"
                pip install --user .
                cd "${USER_WD}"
                ;;
            meson)
                echo "[INFO] Trying automated meson build/ninja install"
                echo "[contd..] In $1"
                cd "$1"
                echo "[INFO] Working in $PWD"
                gitman -c "$PWD/subprojects"
                mkdir -p "./build/update"
                meson --wipe --buildtype=release --prefix="${PREFIX}" -Db_lto=true "./build/update"\
                    || meson --buildtype=release --prefix="${PREFIX}" -Db_lto=true "./build/update"
                cd ./build/update
                ninja
                ninja install
                cd "${USER_WD}"
                ;;
            *)
                true
                ;;
        esac
    fi
}

function auto_install () {
    makefile=()
    meson=()
    pysetup=()
    unknown=()
    for gitdir in ${PULL_SUCCESS[@]}; do
        if [[ -f "$gitdir/meson.build" ]]; then
            meson+=($gitdir)
        else
            if [[ -f "$gitdir/Makefile" ]]; then
                makefile+=($gitdir)
            else
                if [[ -f "$gitdir/setup.py" ]]; then
                    pysetup+=($gitdir)
                else
                    unknown+=($gitdir)
                fi
            fi
        fi
    done
    if [[ -n $makefile ]]; then
        echo ""
        echo "[INFO] Running"
        echo ""
        echo "[INFO] ./configure"
        echo "[INFO] make"
        echo "[INFO] make install"
        echo "[INFO] In following projects to install them"
        echo ""
        for proj in ${makefile[@]}; do
            echo "    [LIST] $proj"
            bootstrap_install "$proj" "make"
        done
        echo ""
    fi
    if [[ -n $meson ]]; then
        echo ""
        echo "[INFO] Trying"
        echo ""
        echo "[INFO] meson/ninja"
        echo "[INFO] In following projects to install them"
        echo ""
        for proj in ${meson[@]}; do
            echo "    [LIST] $proj"
            bootstrap_install "$proj" "meson"
        done
        echo ""
    fi
    if [[ -n $pysetup ]]; then
        echo ""
        echo "[INFO] Trying"
        echo "[INFO] pip/setup.py"
        echo "[INFO] In following projects to install them"
        echo "[INFO] "
        for proj in ${pysetup[@]}; do
            echo "    [LIST] $proj"
            bootstrap_install "$proj" "pysetup"
        done
        echo ""
    fi
    if [[ -n $unknown ]]; then
        echo ""
        echo ""
        echo "[INFO] Installation routines for following programs"
        echo "[INFO] Couldn't be guessed"
        echo ""
        for proj in ${unknown[@]}; do
            echo "    [LIST] $proj"
        done
        echo ""
    fi
    makefile=
    meson=
    pysetup=
    unknown=
}

function new_install() {
    mkdir -p "$CLONE_DIR"
    for url in ${INSTALL_LIST[@]}; do
        if [[ "$url" =~ ":" ]]; then
            package=$(echo "$url" \
                          | rev \
                          | cut -d ":" -f 1 \
                          | rev \
                          | cut -d "." -f 1)
        else
            package=$(echo "$url" \
                          | rev \
                          | cut -d "/" -f 1 \
                          | rev \
                          | cut -d "." -f 1)
        fi
        package_dir="${CLONE_DIR}/${package}"
        if [[ -d "$package_dir" ]]; then
            echo "[WARNING] $package appears to be installed already"
        else
            if [[ -f "$package_dir" ]]; then
                echo "[WARNING] A file '$package_dir' already exists"
                package_dir="${package_dir}.d"
                if [[ -d "$package_dir" ]]; then
                    echo ""
                    echo "[WARNING] ${packagedir} also exists,"
                    echo "[ERROR] This is too much to handle..."
                    echo "Bye..."
                    echo ""
                fi
                echo "[ASRNING] Calling this project '$package_dir'"
            fi
        fi
        cd "${CLONE_DIR}"
        mkdir "$package_dir"
        git clone "$url" "$package_dir"
        cd "$package_dir"
        if [[ -f "./meson.build" ]]; then
            bootstrap_install $package_dir meson
        else
            if [[ -f "./Makefile" ]]; then
                bootstrap_install $package_dir make
            else
                if [[ -f "./setup.py" ]]; then
                    bootstrap_install $package_dir pysetup
                else
                    echo ""
                    echo "[WARNING] Couldn't guess installation method"
                    echo "[ACT] Please install manually"
                    echo "[SUGGEST] cd $package_dir"
                fi
            fi
        fi
        cd "$USER_WD"
    done
    package=
    package_dir=
    url=
}

function del_proj() {
    for package in ${DEL_PACK[@]}; do
        if [[ ! -d "${CLONE_DIR}/${package}" ]]; then
            echo "[WARNING] ${package} not found in ${CLONE_DIR}"
            echo "[WARNING] Ignoring..."
        else
            cd "${CLONE_DIR}/${package}"
            fetch_source=$(git remote -v |grep "fetch" | cut -d " " -f 1 | cut -f 2)
            echo "[INFO] Deleting ${PWD}"
            echo "[INFO] I can't guess which files were installed."
            echo "[INFO] So, leaving those scars behind..."
            echo "[INFO] This project may be added again from the following path"
            echo "[INFO] ${fetch_source}"
            cd "${CLONE_DIR}"
            rm -rf "${CLONE_DIR}/${package}"
            fetch_source=
        fi
    done
    package=
}

function main() {
    init
    argParse "$@"
    fill_defaults
    permission_check
    del_proj
    find_gits
    git_pulls
    auto_install
    new_install
    cd "$USER_WD"
    echo "[DONE] Done."
    exitDoor 0
}

main "$@"
exit 0
